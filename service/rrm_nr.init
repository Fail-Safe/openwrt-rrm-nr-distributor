#!/bin/sh /etc/rc.common
#file: /etc/init.d/rrm_nr
## Based on: https://forum.openwrt.org/t/how-does-rrm-work/32635/68

START=99

NAME=rrm_nr
USE_PROCD=1
RRM_NR_INIT_VERSION="2.0.0-beta"
EXTRA_COMMANDS="mapping neighbors cache refresh diag metrics timing_check timing-check version status"
EXTRA_HELP="  mapping        Show iface->SSID mapping\n  neighbors      Dump current neighbor lists\n  cache          Show cache directory summary\n  refresh        Force immediate refresh (SIGUSR1)\n  diag           Probe readiness timings (per iface)\n  metrics        Show metrics counters (if present)\n  timing_check   Alias of diag (timing-check also accepted)\n  version        Show init script version + git hash (if available)\n  status         Show runtime state + metrics summary\n"

. /lib/functions.sh
. /lib/rrm_nr_common.sh 2>/dev/null || true

CFG_UPDATE_INTERVAL=60
CFG_JITTER_MAX=10
CFG_DEBUG=0
CFG_UMDNS_REFRESH_INTERVAL=30
CFG_UMDNS_SETTLE_DELAY=0
CFG_SKIP_IFACES=""
CFG_ENABLED=1

append_skip_iface() {
	val="$1"
	[ -n "$val" ] && CFG_SKIP_IFACES="${CFG_SKIP_IFACES} ${val}"
}

load_rrm_nr_config() {
	CFG_SKIP_IFACES=""
	config_load rrm_nr
	config_get CFG_ENABLED global enabled 1
	config_get CFG_UPDATE_INTERVAL global update_interval 60
	config_get CFG_JITTER_MAX global jitter_max 10
	config_get CFG_DEBUG global debug 0
	config_get CFG_UMDNS_REFRESH_INTERVAL global umdns_refresh_interval 30
	config_get CFG_UMDNS_SETTLE_DELAY global umdns_settle_delay 0
	config_get skip_ifaces global skip_ifaces ""
	[ -n "$skip_ifaces" ] && CFG_SKIP_IFACES="${CFG_SKIP_IFACES} ${skip_ifaces}"
	config_list_foreach global skip_iface append_skip_iface
	# de-dup & normalize whitespace (shared helper)
	CFG_SKIP_IFACES=$(normalize_iflist "$CFG_SKIP_IFACES")
}


get_wifi_iface_count() { grep -c 'wifi-iface' /etc/config/wireless; }

get_enabled_iface_count() {
	count=0
	total=$(get_wifi_iface_count)
	seq_end=$((total - 1))
	for i in $(seq 0 "$seq_end"); do
		disabled=$(uci -q get wireless.@wifi-iface[$i].disabled 2>/dev/null)
		[ "$disabled" = "1" ] && continue
		count=$((count + 1))
	done
	echo "$count"
}

start_service() {
	[ ! -f /etc/config/wireless ] && logger -t "${NAME}" -p daemon.error "/etc/config/wireless does not exist" && exit 1

	load_rrm_nr_config
	if [ "$CFG_ENABLED" = "0" ]; then
		logger -t "${NAME}" -p daemon.info "Disabled via UCI (rrm_nr.global.enabled=0)"
		exit 0
	fi

	# Optional config: /etc/config/rrm_nr
	# config rrm_nr 'global'
	#   option update_interval '60'
	#   option jitter_max '10'
	#   option enabled '1'
	#   option debug '0'
	#   option umdns_refresh_interval '30'
	#   option umdns_settle_delay '0'
	#   option skip_ifaces 'wlan1-1 wlan0'   # space-separated interface list to skip

	RRM_NR_UPDATE_INTERVAL=$CFG_UPDATE_INTERVAL
	RRM_NR_JITTER_MAX=$CFG_JITTER_MAX
	RRM_NR_DEBUG=$CFG_DEBUG
	RRM_NR_UMDNS_REFRESH_INTERVAL=$CFG_UMDNS_REFRESH_INTERVAL
	RRM_NR_UMDNS_SETTLE_DELAY=$CFG_UMDNS_SETTLE_DELAY
	skip_ifaces=$CFG_SKIP_IFACES

	#todo skip if nr is disabled for interface, skip disabled interface etc.
	wifi_iface_count=$(get_wifi_iface_count)
	[ "$wifi_iface_count" -eq 0 ] && logger -t "${NAME}" -p daemon.error "No wifi-iface stanzas found in /etc/config/wireless" && exit 1

	enabled_iface_count=$(get_enabled_iface_count)
	[ "$enabled_iface_count" -eq 0 ] && logger -t "${NAME}" -p daemon.error "No enabled wifi-iface stanzas found in /etc/config/wireless" && exit 1

	logger -t "${NAME}" -p daemon.info "Waiting for all wireless interfaces to initialize."
	wait_start=$(date +%s 2>/dev/null)
	[ -z "$wait_start" ] && wait_start=0
	timeout_sec=$((5 * 60)) # 5 minute safety timeout
	while :; do
		current=$(ubus list hostapd.* | wc -l)
		expected=$(get_enabled_iface_count)
		[ "$current" = "$expected" ] && break
		now=$(date +%s 2>/dev/null); [ -z "$now" ] && now=$wait_start
		if [ $((now - wait_start)) -ge "$timeout_sec" ]; then
			logger -t "${NAME}" -p daemon.error "Timeout waiting for hostapd objects (got $current / expected $expected). Check wireless config & hostapd logs." && exit 1
		fi
		sleep 3
	done
	logger -t "${NAME}" -p daemon.info "All wireless interfaces are initialized."

	OIFS=$IFS
	# Use newline IFS (portable) by assigning actual newline via command substitution
	IFS="$(printf '\n')"

	rrm_own=""
	ssid_count=0
	skipped_unready=""
	for value in $(ubus list hostapd.*); do
		iface_name=${value#hostapd.}
		skip=0
		for s in $skip_ifaces; do # intentional splitting (space-delimited list)
			[ "$iface_name" = "$s" ] && skip=1 && break
		done
		[ $skip -eq 1 ] && continue
		curr_json=$(rrm_get_own_quick "$iface_name") || {
			logger -t "${NAME}" -p daemon.warning "Skipping $iface_name: rrm_nr_get_own not ready after quick retries"
			skipped_unready="${skipped_unready} ${iface_name}"
			continue
		}
		curr_value=$(echo "$curr_json" | jsonfilter -e '$.value')
		ssid_count=$((ssid_count + 1))
		rrm_own="${rrm_own}+SSID${ssid_count}=${curr_value}"
	done

	# Summarize skipped interfaces (optional concise count)
	if [ -n "$skipped_unready" ]; then
		# Temporarily switch IFS to space+tab to count space-delimited names we accumulated
		_saved_IFS=$IFS
		IFS=' 	'
		# shellcheck disable=SC2086 # intentional word splitting for counting
		set -- $skipped_unready
		count=$#
		IFS=$_saved_IFS
		skipped_unready_display=${skipped_unready# } # Trim leading space
		plural="s"; [ "$count" -eq 1 ] && plural=""
		logger -t "${NAME}" -p daemon.warning "Summary: skipped $count interface${plural} not ready after quick retries: $skipped_unready_display"
	fi

	rrm_own="${rrm_own#*+}"
	IFS='+'
	# shellcheck disable=SC2086 # intentional splitting of constructed positional args
	set -- $rrm_own

	IFS=$OIFS

	procd_open_instance
	procd_set_param term_timeout 5
	procd_set_param env \
		RRM_NR_UPDATE_INTERVAL="$RRM_NR_UPDATE_INTERVAL" \
		RRM_NR_JITTER_MAX="$RRM_NR_JITTER_MAX" \
		RRM_NR_DEBUG="$RRM_NR_DEBUG" \
		RRM_NR_UMDNS_REFRESH_INTERVAL="$RRM_NR_UMDNS_REFRESH_INTERVAL" \
		RRM_NR_UMDNS_SETTLE_DELAY="$RRM_NR_UMDNS_SETTLE_DELAY" \
		RRM_NR_SKIP_IFACES="$skip_ifaces"
	procd_set_param command /bin/sh "/usr/bin/rrm_nr"
	procd_add_mdns "rrm_nr" "udp" "5247" "$@"
	procd_close_instance
}

boot() {
	start
}

service_triggers() {
	procd_add_reload_trigger "network" "wireless"
}

# Expose a user-invoked reload that sends SIGHUP to the running daemon so it
# can rebuild interface mapping and skip list without full restart.
reload_service() {
	procd_send_signal rrm_nr 1
}

status_service() {
	state_file="/tmp/rrm_nr_runtime"
	metrics_file="/tmp/rrm_nr_metrics"
	if [ -f "$state_file" ]; then
		printf 'rrm_nr status:\n'
		sed 's/^/  /' "$state_file"
		[ -f "$metrics_file" ] && { printf '  metrics:\n'; sed 's/^/    /' "$metrics_file"; }
	else
		echo "rrm_nr status: runtime state not yet written (daemon starting?)"
	fi
}

# Print iface->SSID mapping (live)
mapping_service() { rrm_nr_map_ifaces | sed 's/^/  /'; }

# Dump current neighbor list per interface
neighbors_service() {
	for obj in $(ubus list hostapd.* 2>/dev/null); do
		ifc=${obj#hostapd.}
		printf '%s:\n' "$ifc"
		ubus call "$obj" rrm_nr_list 2>/dev/null | sed 's/^/  /'
	done
}

# Show cache directory overview
cache_service() {
	dir=/tmp/rrm_nr_state/group_cache
	[ ! -d "$dir" ] && { echo "cache: directory not present"; return; }
	for f in "$dir"/*.list; do [ -f "$f" ] || continue; h=$(basename "$f"); sz=$(wc -c < "$f" 2>/dev/null); mt=$(date -r "$f" +%s 2>/dev/null || stat -c %Y "$f" 2>/dev/null); head=$(head -c 60 "$f" 2>/dev/null); printf '%s size=%s mtime=%s sample=%s\n' "$h" "$sz" "$mt" "$head"; done
}

# Force immediate refresh via SIGUSR1
refresh_service() {
	procd_send_signal rrm_nr 10  # USR1
}

# One-shot readiness diagnostic (adaptive retries summary)
diag_service() { for obj in $(ubus list hostapd.* 2>/dev/null); do rrm_nr_probe_iface "${obj#hostapd.}"; done; }

metrics_service() { [ -f /tmp/rrm_nr_metrics ] && cat /tmp/rrm_nr_metrics || echo 'metrics: unavailable'; }

timing_check_service() { for obj in $(ubus list hostapd.* 2>/dev/null); do rrm_nr_probe_iface "${obj#hostapd.}"; done; }

version_service() {
	printf 'rrm_nr init version=%s' "$RRM_NR_INIT_VERSION"
	githash=$(git -C /etc/rc.d rev-parse --short HEAD 2>/dev/null || true)
	[ -n "$githash" ] && printf ' git=%s' "$githash"
	printf '\n'
}

extra_command() { case "$1" in mapping|neighbors|cache|refresh|diag|metrics|timing-check|timing_check|version) return 0;; esac; return 1; }
mapping() { mapping_service; }
neighbors() { neighbors_service; }
cache() { cache_service; }
refresh() { refresh_service; }
diag() { diag_service; }
metrics() { metrics_service; }
timing_check() { timing_check_service; }
version() { version_service; }
